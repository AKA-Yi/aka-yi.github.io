<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/21/hello-world/"/>
      <url>/2023/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 1 </category>
          
          <category> 2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23考研-数据结构-线性表</title>
      <link href="/2022/05/02/Linear/"/>
      <url>/2022/05/02/Linear/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>1、线性表是具有<font color=blue><strong>相同</strong></font>数据类型的n（n ＞&#x3D; 0）个<font color=purple><strong>数据元素</strong></font>的<font color=blue><strong>有限序列</strong></font>，其中 n 为<font color=red><strong>表长</strong></font>。</p><p>2、当 n &#x3D; 0 时，线性表为一个<font color=red><strong>空表</strong></font>。</p><p>3、若用 L 命名线性表，则其一般表示为：</p><p><font color=red><strong>L &#x3D; (a<sub>1</sub>, a<sub>2</sub>, …, a<sub>i</sub>, a<sub>i + 1</sub>, …, a<sub>n</sub>)</strong></font></p><p><strong>几个概念：</strong></p><p>1、a<sub>i</sub> 是线性表中的“第 i 个”元素线性表中的<font color=red><strong>位序(位序从 1 开始，下标从 0 开始)</strong></font>。</p><p>2、a<sub>1</sub> 是<font color = red><strong>表头元素</strong></font>， a<sub>n</sub>是<font color = red><strong>表尾元素</strong></font>。</p><p>3、除第一个元素外，每个元素有且仅有一个<font color = red><strong>直接前驱</strong></font>；除最后一个元素外，每个元素有且仅有一个<font color = red><strong>直接后继</strong></font>。</p><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/dKv495687RsQcx2.png" alt="image.png"></p><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InitList</span>(&amp;L); <span class="comment">// 初始化表。构造一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="built_in">DestoryList</span>(&amp;L);<span class="comment">// 销毁操作。销毁线性表，并释放线性表L所占空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListInsert</span>(&amp;L,i,e);<span class="comment">// 插入操作。在表L中第i个位置插入指定元素 e</span></span><br><span class="line"><span class="built_in">ListDelete</span>(&amp;L,i,&amp;e);<span class="comment">// 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">LocateElem</span>(L,e);<span class="comment">// 按值查找操作。在表L中查找具有给定关键字值的元素</span></span><br><span class="line"><span class="built_in">GetElem</span>(L,i);<span class="comment">// 按位查找操作。获取表L中第i个位置的元素的值 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Length</span>(L);<span class="comment">// 求表长。返回线性表L的长度，即L中元素的个数。</span></span><br><span class="line"><span class="built_in">PrintList</span>(L);<span class="comment">// 输出操作。按前后顺序输出线性表L的所有元素值</span></span><br><span class="line"><span class="built_in">Empty</span>(L);<span class="comment">// 判空操作。若L为空表，则返回true，否则返回false</span></span><br></pre></td></tr></table></figure><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="什么是顺序表"><a href="#什么是顺序表" class="headerlink" title="什么是顺序表"></a>什么是顺序表</h2><p>顺序表是用<font color = red><strong>顺序存储结构</strong></font>来存储的线性表。</p><h2 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h2><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>通过定义一个<font color = red><strong>静态数组</strong></font>来存放顺序表中的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];<span class="comment">// 用静态的“数组”存放数据元素</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">// 记录顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">// 顺序表的类型定义</span></span><br></pre></td></tr></table></figure><p><strong>静态分配的基本操作</strong></p><p><strong>1、初始化一个顺序表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;<span class="comment">// 顺序表初始长度为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、打印整个顺序表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i ++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data[%d] = %d\n&quot;</span>, i, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态分配的缺点</strong></p><p>静态分配使用数组存放数据，表长是<font color=red><strong>确定的</strong></font>，如果数组存满了就无法继续存放数据。</p><p>如果一开始就声明一个很大的内存空间，有可能会<font color=red><strong>造成空间的浪费</strong></font>。</p><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>通过<font color = red><strong>malloc函数</strong></font>动态申请内存空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;<span class="comment">// 指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;<span class="comment">// 顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><p><strong>动态分配的基本操作</strong></p><p><strong>1、初始化一个顺序表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">   <span class="comment">// 使用 malloc 函数申请一片连续的内存空间</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;<span class="comment">// 初始化当前顺序表长度为 0</span></span><br><span class="line">    L.MaxSize = InitSize;<span class="comment">// 初始化顺序表的最大长度为InitSize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、增加动态数组的长度</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = L.data;<span class="comment">// 定义一个临时变量 p 来记录原表所指向的起始地址</span></span><br><span class="line">    <span class="comment">// 重新申请一片长度为L.MaxSize + len的内存空间</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize + len)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i ++ )&#123;</span><br><span class="line">        L.data[i] = p[i];<span class="comment">// 将原表中的元素赋值到新申请的地址中</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len；<span class="comment">// 重新计算 L 的最大容量</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">// 释放p指针所指向的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h2><p>1、<font color = red><strong>随机访问</strong></font>，即可以在O(1)时间内找到第i个元素。</p><p>2、存储密度高，每个节点只存储数据元素</p><p>3、拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</p><p>4、插入、删除操作不方便，需要移动大量元素</p><h2 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h2><p><strong>注：</strong>顺序表的基本操作均基于<strong>静态分配</strong>方式说明</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向顺序表中位序为 i 的位置插入一个元素 n</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertSeqList</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断输入是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前存储空间是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.Maxsize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆序遍历，将第i个元素及后面的元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 e 复制到下标为 i - 1 的位置</span></span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    <span class="comment">// 更新 L 的长度</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><blockquote><p><strong>最好情况:新元素插入到表尾，不需要移动元素</strong><br>        i &#x3D; n + 1，循环 0 次<br>        最好时间复杂度 &#x3D; O(1)</p><p><strong>最坏情况:新元素插入到表头，需要将原有的n个元素全都向后移动</strong><br>        i &#x3D; 1，循环 n 次<br>        最坏时间复杂度 &#x3D; O(n);</p><p><strong>平均情况:假设新元素插入到任何一个位置的概率相同</strong><br>        即i&#x3D;1,2,3.. , length+1的概率都是p&#x3D;1&#x2F;(n+1)<br>        平均时间复杂度：O(n)</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除顺序表中位序为 i 的元素并且返回被删除的值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteSeqlist</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断输入是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// e 记录被删除的元素的值</span></span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将第 i 个位置后的元素前移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j] = L.data[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 L 的长度</span></span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><blockquote><p><strong>最好情况:删除表尾元素，不需要移动其他元素</strong><br>        i &#x3D; n，循环 0 次;<br>        最好时间复杂度 &#x3D; O(1)</p><p><strong>最坏情况:删除表头元素，需要将后续的n-1个元素全都向前移动</strong><br>        i &#x3D; 1，循环 n - 1 次;<br>        最坏时间复杂度 &#x3D; O(n);</p><p><strong>平均情况:假设删除任何一个元素的概率相同，即 i&#x3D; 1,2,3…. length 的概率都是 p &#x3D; 1&#x2F;n</strong><br>        i &#x3D; 1，循环n-1次; i &#x3D; 2，循环n-2次; i &#x3D; 3，循环n-3次 … i &#x3D; n时，循环0次<br>        平均时间复杂度 &#x3D; O(n)</p></blockquote><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取表中第 i 个位置的元素的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];<span class="comment">// 直接返回下标为 i - 1 的元素的值即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><blockquote><p>因为顺序表是连续存放的，所以直接返回数组下标对应的元素即可<br>        时间复杂度：O(1)</p></blockquote><p><strong>注：</strong></p><p><strong>1、动态分配与静态分配均可直接返回数组下标对应的元素的值</strong></p><p><strong>2、按位查找体现出顺序表的<font color=red>随机存取</font>的特性</strong></p><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在顺序表中查找第一个元素值为e的元素，并返回其位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)&#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><blockquote><p><strong>最好情况:目标元素在表头</strong><br>        循环1次<br>        最好时间复杂度 &#x3D; O(1)</p><p><strong>最坏情况:目标元素在表尾</strong><br>        循环n次<br>        最坏时间复杂度 &#x3D; O(n)</p><p><strong>平均情况:假设目标元素出现在任何一个位置的概率</strong><br>        目标元素在第1位，循环1次;在第2位，循环2次;….;在第n位，循环n次<br>        平均时间复杂度 &#x3D; O(n)</p></blockquote><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="什么是单链表"><a href="#什么是单链表" class="headerlink" title="什么是单链表"></a>什么是单链表</h2><p>通过<font color= red><strong>链式存储</strong></font>的方式存储的顺序表.</p><p>每个结点除了存放<font color= red><strong>数据元素</strong></font>外，还有存储<font color= red><strong>指向下一个节点的指针</strong></font>。</p><h2 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> LNode&#123;</span><br><span class="line">    ElemType data;<span class="comment">// 结点中存放元素值，Elemtype为题目要求的数据类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;<span class="comment">// 存放指向像一个结点的指针</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><blockquote><p>因为可以通过头结点来表示整个单链表，所以我们可以声明两个不同的变量名称来提高代码的可读性<br>        1、若强调当前为一个单链表，则使用 LinkList 作为变量名<br>        2、若强调当前为头结点，则使用 LNode * 作为变量名</p></blockquote><h2 id="单链表的特点"><a href="#单链表的特点" class="headerlink" title="单链表的特点"></a>单链表的特点</h2><blockquote><p>1、不要求大片的连续空间，改变容量方便<br>2、不可随机存取，要耗费一定空间存放</p></blockquote><h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>1、带头结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个单链表(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">// L 申请一个内存空间作为头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 若 L = NULL 说明申请失败，内存不足</span></span><br><span class="line">    &#125;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 头结点后暂时还没有其他结点，故指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、不带头结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个单链表(不带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;<span class="comment">// L不作为头结点，直接记录为空即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、对比</strong></p><blockquote><p>不带头结点，写代码更麻烦<br>对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑<br>对空表和非空表的处理需要用不同的代码逻辑</p><p>带头结点方便后续操作</p></blockquote><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><h4 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h4><p><strong>1、带头结点</strong></p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 判断输入是否合法</span></span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;<span class="comment">// 定义一个指针 p ，指向当前所遍历到的结点</span></span><br><span class="line">    p = L;<span class="comment">// 初始化指向头结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">// 记录当前 p 指向的是第几个结点   </span></span><br><span class="line">    <span class="comment">// 逐个遍历，找到第 i - 1 个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;<span class="comment">// 若 p 遍历完成之后为 null，说明i不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请一个存储空间来存放要插入的结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;<span class="comment">// 赋值到新申请的结点</span></span><br><span class="line">    s -&gt; next = p -&gt; next;<span class="comment">// 将新申请的结点指向原来第i个结点所指向的结点</span></span><br><span class="line">    p -&gt; next = s;<span class="comment">// 将原来第i个结点的指针指向新申请的结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/12/AunlvTszKw9i2rS.png" alt="1652327016_1_.jpg"></p><p><strong>注意：</strong></p><blockquote><p>第19行和第20行代码<font color =red><strong>不可调换顺序</strong></font><br>若先执行第20行代码，会先将 p 所指结点的指针指向 s 所指向的结点<br>那么再执行第19行代码的话 s 所指向的结点的指针将会指向本身，形成自环</p></blockquote><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/12/YFCLkB9Vn28DPHg.png" alt="1652327082_1_.jpg"></p><p><strong>时间复杂度分析</strong></p><blockquote><p><strong>最好情况：插入位置在表头</strong><br>        循环1次<br>        最好时间复杂度：O(1)</p><p><strong>最坏情况:插入位置在表尾</strong><br>        循环n次<br>        最坏时间复杂度 &#x3D; O(n)</p><p><strong>平均情况:假设插入位置出现在任何一个位置的概率相同</strong><br>        插入位置在第1位，循环1次;在第2位，循环2次;….;在第n位，循环n次<br>        平均时间复杂度 &#x3D; O(n)</p></blockquote><p><strong>2、不带头结点</strong></p><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">   <span class="comment">// 输入不合法</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为没有头结点，故插入第一个结点的操作与插入其他结点不同</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = e;</span><br><span class="line">        s -&gt; next = L;</span><br><span class="line">        L = s;<span class="comment">// 头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;<span class="comment">// 指针 p 指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">// 记录当前 p 指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">// p 初始指向头指针所指向的结点（非头结点）</span></span><br><span class="line">    <span class="comment">// 循环找到第 i - 1 个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入不合法</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/03/SRJbkfvUsNI6Ma1.png" alt="1651550344_1_.jpg"></p><p><strong>注意：</strong></p><blockquote><p>第 10 行和第 11 行 以及 第 28 行和第 29 行代码不可调换顺序，否则会出现自环的情况</p></blockquote><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/03/eQcNgzGjEPRqxtJ.png" alt="1651551439_1_.jpg"></p><p><strong>时间复杂度分析：</strong></p><blockquote><p><strong>最好情况：插入位置在表头</strong><br>        循环1次<br>        最好时间复杂度：O(1)</p><p><strong>最坏情况:插入位置在表尾</strong><br>        循环n次<br>        最坏时间复杂度 &#x3D; O(n)</p><p><strong>平均情况:假设插入位置出现在任何一个位置的概率相同</strong><br>        插入位置在第1位，循环1次;在第2位，循环2次;….;在第n位，循环n次<br>        平均时间复杂度 &#x3D; O(n)</p></blockquote><h4 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h4><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后插操作：在 p 结点之后插入元素 e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">// 内存分配失败</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s -&gt; data = e;<span class="comment">// 用结点 s 保存数据元素 e</span></span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = s;<span class="comment">// 将结点 s 连接到 p 之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第 i 个位置插入元素 e （带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;<span class="comment">// 指针 p 指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">// 记录当前 p 指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">// L 指向头结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环找到第 i - 1 个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用后插操作函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InsertNextNode</span>(p, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><blockquote><p><strong>后插操作：在 p 结点之后插入元素 e</strong></p><p>​不需要循环遍历直接插入即可</p><p>​时间复杂度：O(1)</p><p><strong>在第 i 个位置插入元素 e</strong></p><p>​需要循环遍历找到第 i - 1 个位置</p><p>​平均时间复杂度：O(n)</p></blockquote><h4 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h4><p><strong>Code1：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前插操作：在 p 结点之前插入元素 e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">// 内存分配失败</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = s;<span class="comment">// 将结点 s 连接到 p 之后</span></span><br><span class="line">    s -&gt; data = p -&gt; data;<span class="comment">// 用结点 s 保存数据元素 e</span></span><br><span class="line">    p -&gt; data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code2：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前插操作：在 p 结点之前插入元素 e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">// 内存分配失败</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = s;<span class="comment">// 将结点 s 连接到 p 之后</span></span><br><span class="line">    ElemType temp = p -&gt; data;<span class="comment">// 交换数据域部分</span></span><br><span class="line">    p -&gt; data = s;</span><br><span class="line">    s -&gt; data = p -&gt; data;</span><br><span class="line">    p -&gt; data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><blockquote><p><strong>给定结点的前插操作相当于找到该结点的前驱结点进行后插操作</strong></p><p>​找到前驱结点需要的平均时间复杂度为：O(n)</p><p><strong>前插操作：在 p 结点之前插入元素 e</strong></p><p>​不论使用上述哪种方式均不需要遍历</p><p>​故时间复杂度均为：O(1)</p></blockquote><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h4><p><strong>Code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;<span class="comment">// 指针 p 指向当前所扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">// 记录 p 当时所指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">// L 指向头结点，初始化 p 也指向头结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环遍历找到第 i - 1 个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入不合法</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第 i - 1 个结点后已无其他结点</span></span><br><span class="line">    <span class="keyword">if</span>(p -&gt; next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *q = p -&gt; next;<span class="comment">// 令 q 指向被删除结点</span></span><br><span class="line">    e = q -&gt; data;<span class="comment">// 用 e 返回被删除的元素的值</span></span><br><span class="line">    p -&gt; next = q -&gt; next;<span class="comment">// 将 q 所指向的结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">// 释放 q 结点所存储的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/12/SFWBLTbh1EAzrJ2.png" alt="1652330542_1_.jpg"></p><p><strong>时间复杂度分析：</strong></p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23考研-数据结构-绪论</title>
      <link href="/2022/05/02/Data_Structures_and_Algorithms/"/>
      <url>/2022/05/02/Data_Structures_and_Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a><strong>数据</strong></h3><p>​<font color="red"><strong>数据</strong></font>是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p><h3 id="数据元素、数据项"><a href="#数据元素、数据项" class="headerlink" title="数据元素、数据项"></a><strong>数据元素、数据项</strong></h3><p>​<font color="red"><strong>数据元素</strong></font>是数据的基本单位，通常作为一个整体进行考虑和处理。<br>​一个数据元素可由若干数据项组成，<font color="red"><strong>数据项</strong></font>是构成数据元素的不可分割的最小单位。</p><h3 id="数据对象、数据结构"><a href="#数据对象、数据结构" class="headerlink" title="数据对象、数据结构"></a><strong>数据对象、数据结构</strong></h3><p>​<font color="red"><strong>数据对象</strong></font>是具有相同性质的数据元素的集合，是数据的一个子集。</p><p>​<font color="red"><strong>数据结构</strong></font>是相互之间存在一种或多种特定关系的数据元素的集合。</p><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><h4 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a><strong>集合结构</strong></h4><p>​各个元素同属一个集合，别无其他关系。</p><p>​<strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/QFTvUesOY173Ckd.png" alt="image.png"></p><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a><strong>线性结构</strong></h4><p>​数据元素是<font color="red"><strong>一对一</strong></font>的关系。</p><p>​除了第一个元素，所有元素都有唯一前驱。</p><p>​除了最后一个元素，所有元素都有唯一后继。</p><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/dKv495687RsQcx2.png" alt="image.png"></p><h4 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a><strong>树形结构</strong></h4><p>​数据元素之间是<font color="red"><strong>一对多</strong></font>的关系</p><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/WXtUdeY4ZNTwmh9.png" alt="image.png"></p><h4 id="图状结构"><a href="#图状结构" class="headerlink" title="图状结构"></a><strong>图状结构</strong></h4><p>​数据元素之间是<font color="red"><strong>多对多</strong></font>的关系</p><p><strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/hkXfTPgsmWS56Zw.png" alt="image.png"></p><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p>​针对于某种逻辑结构，结合实际需求，定义<font color="red"><strong>基本运算</strong></font></p><p>​<strong>例如：逻辑结构-线性结构的基本运算</strong></p><p>​1、查找第 i 个位置元素</p><p>​2、在第 i 个位置插入新的数据元素</p><p>​3、删除第 i 个位置的数据元素</p><p>​……</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font color = "red">注意</font></h4><p>​1、<font color="red"><strong>运算的定义</strong></font>是<font color="red"><strong>针对逻辑结构</strong></font>的，指出运算的功能。</p><p>​2、<font color="red"><strong>运算的实现</strong></font>是<font color="red"><strong>针对存储结构</strong></font>的，指出运算的具体操作步骤。</p><h3 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>​把<font color="red"><strong>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</strong></font>，元素之间的关系由存储单元的邻接关系来表示。</p><p>​<strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/1AKFDmzoa7vIJnX.png" alt="image.png"></p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>​<font color="red"><strong>逻辑上相邻的元素在物理位置上可以不相邻</strong></font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</p><p>​<strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/x7Y8vacSoXV3EpT.png" alt="image.png"></p><h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p>​在存储元素的信息的同时，还建立附加的<font color="red"><strong>索引表</strong></font>。索引表中的每项成为<font color= "red"><strong>索引项</strong></font>，索引项的形式一般是<font color="red"><strong>(关键字,地址)</strong></font>。</p><p>​<strong>图示：</strong></p><p><img src="https://s2.loli.net/2022/05/02/tuGm7KaAQCp46JH.png" alt="image.png"></p><h4 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h4><p>​根据元素的关键字直接计算出该院色的存储地址，又称<font color="red"><strong>哈希（Hash）存储</strong></font>。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a><font color = "red">注意</font></h4><p>1、链式存储， 索引存储，散列存储称为<font color="red"><strong>非顺序存储</strong></font>。</p><p>2、若采用<font color="red"><strong>顺序存储</strong></font>，则各个数据元素在物理上必须是<font color="red"><strong>连续的</strong></font>；若采用<font color="red"><strong>非顺序存储</strong></font>，则各个数据元素在物理上可以是<font color="red"><strong>离散的</strong></font>。<br>2、数据的存储结构会<font color="red"><strong>影响存储空间分配的方便程度</strong></font>。<br>3、数据的存储结构会<font color="red"><strong>影响对数据运算的速度</strong></font>。</p><h2 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><font color="red"><strong>数据类型</strong></font>是<strong>一个值的集合</strong>和<strong>定义在此集合上的一组操作</strong>的总称。</p><p>1、原子类型。其值不可再分的数据类型。<br>2、结构类型。其值可以再分解为若干成分（分量）的数据类型。</p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p><font color="red"><strong>抽象数据类型</strong>（Abstract Data Type, <strong>ADT</strong>）</font>是<strong>抽象数据组织</strong>及<strong>与之相关的操作</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2022/05/02/FJtTVPIbzwhGSmQ.png" alt="image.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>​算法（Algorithm）是<font color="red"><strong>对特定问题求解步骤的一种描述</strong></font>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p><p><strong>注意</strong></p><p>​<font color="red"><strong>程序 &#x3D; 数据结构 + 算法</strong></font></p><p>​1、数据结构是要处理的信息</p><p>​2、算法是处理信息的步骤</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><h3 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h3><p>​一个算法必须在执行有穷步之后结束，且每一步都可在又穷时间内完成。</p><p>​<font color="red"><strong>注意：算法</strong></font>必须是<font color="red"><strong>有穷的</strong></font>，而<font color="red"><strong>程序</strong></font>可以是<font color="red"><strong>无穷的</strong></font>。</p><h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><p>​算法的每条指令必须有确切的含义，对于<font color="red"><strong>相同的输入</strong></font>只能得到<font color="red"><strong>相同的输出</strong></font>。</p><h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>​算法中描述的操作都可以通过已经实现的<font color="red"><strong>基本运算执行有限次来实现</strong></font>。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>​一个算法<font color="red"><strong>有零个或多个输入</strong></font>，这些输入取自于某个特定的对象的集合。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>​一个算法<font color="red"><strong>有一个或多个输出</strong></font>，这些输出是与输入有着某种特定关系的两。</p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>​算法的特性是一个算法<font color="red"><strong>必须要满足</strong></font>的性质，缺一不可。</p><h2 id="”好“算法的特质"><a href="#”好“算法的特质" class="headerlink" title="”好“算法的特质"></a>”好“算法的特质</h2><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>​算法应能够<font color=red><strong>正确的解决求解问题</strong></font>。</p><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>​算法应具有<font color=red><strong>良好的可读性</strong></font>，以帮助人们理解。</p><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>​输入非法数据时，算法能<font color=red><strong>适当的作出反应或进行处理</strong></font>，而不会产生莫名其妙的输出结果。</p><h3 id="高效率与低存储量需求"><a href="#高效率与低存储量需求" class="headerlink" title="高效率与低存储量需求"></a>高效率与低存储量需求</h3><p>​高效率：花的时间少，<font color="red"><strong>时间复杂度低</strong></font>。</p><p>​低存储量：不费内存，<font color=red><strong>空间复杂度低</strong></font>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2022/05/02/GouwVmNz7MlpfYB.png" alt="image.png"></p><h1 id="算法的效率"><a href="#算法的效率" class="headerlink" title="算法的效率"></a>算法的效率</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="什么是算法的时间复杂度"><a href="#什么是算法的时间复杂度" class="headerlink" title="什么是算法的时间复杂度"></a>什么是算法的时间复杂度</h3><p><font color=red><strong>事先预估</strong></font>算法<font color=red><strong>时间开销 T(n)</strong></font> 与<font color=red><strong>问题规模 n</strong></font> 的关系。（T 表示 “Time”）</p><h3 id="如何计算时间复杂度"><a href="#如何计算时间复杂度" class="headerlink" title="如何计算时间复杂度"></a>如何计算时间复杂度</h3><p>​1、找到一个<font color=red><strong>基本操作（最深层循环）</strong></font>。</p><p>​2、分析该基本操作的<font color=red><strong>执行次数 x</strong></font>   与 <font color=red><strong>问题规模 n</strong></font>的关系 <font color=red><strong>x &#x3D; f(n)</strong></font>。</p><p>​3、x 的数量级 <font color=red><strong>O(x)</strong></font>  就是算法的时间复杂度 T(n)。</p><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><p><strong>加法规则：</strong></p><p>​O(f(n)) + O(g(n)) &#x3D; O(max(f(n),g(n))</p><p><strong>乘法规则：</strong></p><p>​O(f(n)) * O(g(n)) &#x3D; O (f(n)*g(n))</p><p><strong>常见时间复杂度的大小：</strong></p><p>​O(1) &lt; O(log<sub>2</sub>n) &lt; O(n) &lt; O(n * log<sub>2</sub>n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>)  &lt; O(n!) &lt; O(n<sup>n</sup>) </p><p><strong>注意：</strong></p><p>​常数级别的复杂度可以忽略不计，即：O(4n) &#x3D; O(n)</p><h3 id="三种复杂度"><a href="#三种复杂度" class="headerlink" title="三种复杂度"></a>三种复杂度</h3><h4 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h4><p>​考虑输入数据<font color=red><strong>最坏</strong></font>的情况.</p><h4 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h4><p>​考虑所有输入数据都<font color=red><strong>等概率出现</strong></font>的情况.</p><h4 id="最好时间复杂度"><a href="#最好时间复杂度" class="headerlink" title="最好时间复杂度"></a>最好时间复杂度</h4><p>​考虑输入数据<font color=red><strong>最好</strong></font>的情况.</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h4 id="逐步递增型输出"><a href="#逐步递增型输出" class="headerlink" title="逐步递增型输出"></a>逐步递增型输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        i ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逐行分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第 2 行语句共执行 1 次</span><br><span class="line">第 3 行语句共执行 n + 1</span><br><span class="line">第 4 和第 5行语句分别执行 n 次</span><br><span class="line">第 7 行语句共执行 1 次</span><br><span class="line">故整体时间复杂度为 T(n) = 3n + 3 = O(n)</span><br></pre></td></tr></table></figure><h4 id="嵌套循环型输出"><a href="#嵌套循环型输出" class="headerlink" title="嵌套循环型输出"></a>嵌套循环型输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        i ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello code!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第 3 行 while 循环共执行 n 次</span><br><span class="line">第 6 行 for 循环共执行 n^2次</span><br><span class="line">故整体时间复杂度为 T(n) = O(n^2) + O(n) = O(n^2)</span><br></pre></td></tr></table></figure><h4 id="指数递增型输出"><a href="#指数递增型输出" class="headerlink" title="指数递增型输出"></a>指数递增型输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        i *= <span class="number">2</span> ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第 4 行，i 成指数型增长</span><br><span class="line">循环结束刚好满足 2^x &gt; n</span><br><span class="line">得出 x = log2n + 1</span><br><span class="line">故整体时间复杂度为 T(n) = O(x) = O(log2n)</span><br></pre></td></tr></table></figure><h4 id="搜索数字型输出"><a href="#搜索数字型输出" class="headerlink" title="搜索数字型输出"></a>搜索数字型输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> flag[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i] == n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若元素 n 在第一个位置，则第一层循环就可以找到    —— 最好时间复杂度  T(n) = O(1)</span><br><span class="line">若元素 n 在最后一个位置，则需要遍历整个数组    —— 最坏时间复杂度  T(n) = O(n)</span><br><span class="line">假设元素 n 在任意一个位置的概率相同为1/n    —— 平均时间复杂度  T(n) = O(n)</span><br></pre></td></tr></table></figure><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="什么是空间复杂度"><a href="#什么是空间复杂度" class="headerlink" title="什么是空间复杂度"></a>什么是空间复杂度</h3><p>​<font color=red><strong>空间开销（内存开销）</strong></font>与<font color=red><strong>问题规模 n</strong></font> 之间的关系。</p><h3 id="如何计算空间复杂度"><a href="#如何计算空间复杂度" class="headerlink" title="如何计算空间复杂度"></a>如何计算空间复杂度</h3><h4 id="普通程序"><a href="#普通程序" class="headerlink" title="普通程序"></a>普通程序</h4><p>​1、找到<font color=red><strong>所占空间大小</strong></font>与问题规模<font color=red><strong>相关的变量</strong></font>。</p><p>​2、分析所占空间x与问题规模n的关系<font color=red><strong>x&#x3D;f(n)</strong></font>。</p><p>​3、×的数量级<font color=red><strong>O(x)</strong></font>就是算法空间复杂度<font color=red><strong>S(x)</strong></font>。</p><h4 id="递归程序"><a href="#递归程序" class="headerlink" title="递归程序"></a>递归程序</h4><p>​1、找到递归调用的深度×与问题规模n的关系×&#x3D;f(n)</p><p>​2、×的数量级O(x)就是算法空间复杂度S(n)</p><p><strong>注意：有的算法各层函数所需存储空间不同，分析方法略有不同</strong></p><h3 id="常用技巧-1"><a href="#常用技巧-1" class="headerlink" title="常用技巧"></a>常用技巧</h3><p><strong>加法规则 :</strong> </p><p>​O(f(n)) + O(g(n)) &#x3D; O(max(f(n), g(n)))</p><p><strong>乘法规则：</strong></p><p>​O(f(n)) × O(g(n)) &#x3D; O(f(n)×g(n))</p><p><strong>常见的空间复杂度的大小：</strong></p><p>O(1) &lt; O(log<sub>2</sub>n) &lt; O(n) &lt; O(nlog<sub>2</sub>n) &lt; O(n) &lt; O(n) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><p><strong>注意：</strong></p><p>​常数级别的复杂度可以忽略不计，即：O(4n) &#x3D; O(n)</p><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设一个 int 类型的变量占 4B 的内存空间</span><br><span class="line">那么 n 占 1 个 int 的空间</span><br><span class="line">flag 占 n 个 int 的空间</span><br><span class="line">i 占 1 个 int 的空间</span><br><span class="line">则所需的内存空间 = 4 + 4n + 4 = 4n + 8</span><br><span class="line">S(n) = O(n)</span><br></pre></td></tr></table></figure><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag[n][n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那么 n 占 1 个 int 的空间</span><br><span class="line">flag 占 n * n 个 int 的空间</span><br><span class="line">i 占 1 个 int 的空间</span><br><span class="line">则所需的内存空间 = 4 + 4(n*n) + 4 = 4n + 8</span><br><span class="line">S(n) = O(n*n)</span><br></pre></td></tr></table></figure><h4 id="一维数组-二维数组"><a href="#一维数组-二维数组" class="headerlink" title="一维数组 + 二维数组"></a>一维数组 + 二维数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag[n][n];</span><br><span class="line">    <span class="type">int</span> other[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag 占 n * n 的空间</span><br><span class="line">other 占 n 的空间</span><br><span class="line">根据加法规则</span><br><span class="line">总的空间复杂度为：S(n) = O(n * n)</span><br></pre></td></tr></table></figure><h4 id="递归型调用"><a href="#递归型调用" class="headerlink" title="递归型调用"></a>递归型调用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">Print</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以看出当 n &gt; 1 时函数调用自身</span><br><span class="line">每次调用一次将会在内存中开辟一块新的内存空间来存储当前的 n</span><br><span class="line">故递归算法的空间复杂度 = 递归调用的深度</span><br><span class="line">S(n) = O(n)</span><br><span class="line">注：[此处的 n 指的是一个函数所占用的总的内存空间]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 研究生入学考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
